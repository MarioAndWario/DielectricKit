!!=========================================================================
!!
!! Module:
!!
!! (1) hdf5_io_m Originally by JIM Last Modified 12/2014 (FHJ)
!!
!! Routines to read and write wavefunctions in 1 format.
!! The code is generated through repeated inclusion of a file with
!! different preprocessor definitions each time. Consult the resulting
!! .p.f file for clarity.
!!
!!=========================================================================
module hdf5_io_m
  use global_m
  use h5lt
  use hdf5
  implicit none
  private
  public :: &
    hdf5_require_version , &
    hdf5_require_flavor , &
    hdf5_create_dset , &
    hdf5_create_group , &
    hdf5_read_int , &
    hdf5_write_int , &
    hdf5_read_int_array , &
    hdf5_write_int_array , &
    hdf5_read_int_hyperslab , &
    hdf5_write_int_hyperslab , &
    hdf5_read_double , &
    hdf5_write_double , &
    hdf5_read_double_array , &
    hdf5_write_double_array , &
    hdf5_read_double_hyperslab , &
    hdf5_write_double_hyperslab , &
    hdf5_read_logical , &
    hdf5_write_logical , &
    hdf5_read_logical_array , &
    hdf5_write_logical_array , &
    hdf5_read_logical_hyperslab , &
    hdf5_write_logical_hyperslab
contains
!> Make file a particular hdf5 file has the correct version number
subroutine hdf5_require_version(loc_id, dset_name, req_version, fname, allow_greater)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in) :: req_version !< version to require
  character(LEN=*), intent(in) :: fname !< file name, for debugging purposes
  !> allow the file to have a version greater than req_version? Defaults to .true.
  logical, intent(in), optional :: allow_greater
  integer :: file_version, errcode
  logical :: allow_greater_
 
  file_version = -1
  call hdf5_read_int(loc_id, dset_name, file_version, errcode)
  allow_greater_ = .true.
  if (present(allow_greater)) allow_greater_ = allow_greater
  if (file_version<req_version .or. &
    (file_version/=req_version.and..not.allow_greater_) .or. errcode/=0) then
    if (peinf%inode==0) then
      write(0,*)
      write(0,*) 'ERROR: Incorrect version in file ', trim(fname),' while reading ',trim(dset_name)
      write(0,*) '       Expecting: ', req_version
      write(0,*) '       Got: ', file_version
      write(0,*) '       Errcode: ', errcode
      write(0,*) 'Your file was probably generated by an older version of BerkeleyGW and'
      write(0,*) 'is now obsolete. Consult the documentation and use the appropriate converter.'
      write(0,*)
    endif
    call die("Wrong version for file '"+trim(fname)+"'.", only_root_writes=.true.)
  endif
 
end subroutine hdf5_require_version
!> Make file a particular hdf5 file has the correct flavor number
subroutine hdf5_require_flavor(loc_id, dset_name, req_flavor, fname)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in) :: req_flavor !< flavor to require
  character(LEN=*), intent(in) :: fname !< file name, for debugging purposes
  integer :: file_flavor, errcode
 
  file_flavor = -1
  call hdf5_read_int(loc_id, dset_name, file_flavor, errcode)
  if (file_flavor/=req_flavor.or.errcode/=0) then
    if (peinf%inode==0) then
      write(0,*)
      write(0,*) 'ERROR: Incorrect flavor in file ', trim(fname), ' while reading ',trim(dset_name)
      write(0,*) '       Expecting: ', req_flavor
      write(0,*) '       Got: ', file_flavor
      write(0,*) '       Errcode: ', errcode
      write(0,*) 'You are probably linking the wrong file or running the BerkeleyGW binary with'
      write(0,*) 'the wrong flavor.'
      write(0,*)
    endif
    call die("Wrong flavor in file "+trim(fname)+"'.", only_root_writes=.true.)
  endif
 
end subroutine hdf5_require_flavor
!> Creates an empty dataset
subroutine hdf5_create_dset(loc_id, dset_name, dtype, dims, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer(HID_T), intent(in) :: dtype
  integer, intent(in) :: dims(:)
  integer, intent(out) :: errcode
  integer(HSIZE_T) :: hdims(size(dims))
  integer(HID_T) :: dset_id
  integer(HID_T) :: dspace
 
  hdims(:) = dims(:)
  call h5screate_simple_f(size(dims), hdims, dspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  call h5dcreate_f(loc_id, dset_name, dtype, dspace, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_create_dset
!> Creates an empty group
subroutine hdf5_create_group(loc_id, group_name, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: group_name !< 1 group name
  integer, intent(out) :: errcode
  integer(HID_T) :: group_id
 
  call h5gcreate_f(loc_id, group_name, group_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  call h5gclose_f(group_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_create_group
!
!==============================================================================
! Included from file hdf5_io_hdf5.f90. Originally by JIM.
! Last modified 12/2014 (FHJ)
!==============================================================================
!/* The following routine reads or writes a scalar value, of type THE_TYPE, from the HDF5 file */
!> Reads a rank-0 integer scalar.
subroutine hdf5_read_int(loc_id, dset_name, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(inout) :: buf !< data buffer
  integer, intent(out) :: errcode !< 1 error code
  integer(HSIZE_T), dimension(1) :: dims_h5type(1)
  integer, dimension(1) :: buf_1(1)
 
  dims_h5type(1) = 0
  call h5ltread_dataset_int_f(loc_id, dset_name, buf_1, dims_h5type, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  buf = buf_1(1)
 
end subroutine hdf5_read_int
!/* The following routine reads or writes an array, of type THE_TYPE, from the HDF5 file */
!> Reads a(n) integer array.
subroutine hdf5_read_int_array(loc_id, dset_name, dims, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in), dimension(:) :: dims !< size of the buffer buf
  integer, intent(inout), dimension(*) :: buf !< data buffer
  integer, intent(out) :: errcode !< error code
  integer :: rank
  integer(HSIZE_T), dimension(size(dims)) :: dims_h5type
 
  rank = size(dims)
  dims_h5type = dims
  call h5ltread_dataset_int_f(loc_id, dset_name, buf, dims_h5type, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_read_int_array
!/* The following routine reads or writes a hyperslab from an array, of type THE_TYPE, from the HDF5 file */
!> Reads a portion of a(n) integer array.
subroutine hdf5_read_int_hyperslab(loc_id, dset_name, countf, offsetf, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  !> Number of elements to read from the dataset for each dimention
  integer, intent(in) :: countf(:)
  !> Offset when reading dataset from file.
  integer, intent(in) :: offsetf(:)
  !> Data buffer. We treat it as a flat contiguous 1D array.
  integer, intent(inout), dimension(*) :: buf
  integer, intent(out) :: errcode !< error code
  integer(HSIZE_T) :: hcountf(size(countf)) !< Count for file dataspace
  integer(HSIZE_T) :: hcountm(1) !< Count for memory dataspace
  integer(HSIZE_T) :: hoffsetf(size(offsetf)) !< Offset for file dataspace
  integer(HID_T) :: dset_id
  integer(HID_T) :: dataspace
  integer(HID_T) :: memspace
  logical :: exists_
 
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 1 error", only_root_writes=.true.)
  endif
  if (.not. exists_) call die('Cannot read/write hyperslap from "'//dset_name//&
       "': dataset doesn`t exists!", only_root_writes=.true.)
  call h5dopen_f(loc_id, dset_name, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 2 error", only_root_writes=.true.)
  endif
  ! FHJ: Get 2D file dataspace and set selection mask
  call h5dget_space_f(dset_id, dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 3 error", only_root_writes=.true.)
  endif
  hcountf(:) = countf(:)
  hoffsetf(:) = offsetf(:)
  call h5sselect_hyperslab_f(dataspace, H5S_SELECT_SET_F, hoffsetf, hcountf, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 4 error", only_root_writes=.true.)
  endif
  ! FHJ: Create flat memory dataspace
  hcountm(1) = product(countf)
  call h5screate_simple_f(1, hcountm, memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 5 error", only_root_writes=.true.)
  endif
  ! FHJ: Read dataspace
  call h5dread_f(dset_id, H5T_NATIVE_INTEGER, buf, hcountm, errcode, memspace, dataspace)
  if (errcode .ne. 0) then
     call die("HDF5 8 error", only_root_writes=.true.)
  endif
  call h5sclose_f(memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 10 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 11 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 12 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_read_int_hyperslab
!
!==============================================================================
! Included from file hdf5_io_hdf5.f90. Originally by JIM.
! Last modified 12/2014 (FHJ)
!==============================================================================
!/* The following routine reads or writes a scalar value, of type THE_TYPE, from the HDF5 file */
!> Writes a rank-0 integer scalar.
subroutine hdf5_write_int(loc_id, dset_name, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in) :: buf !< data buffer
  integer, intent(out) :: errcode !< 1 error code
  integer(HSIZE_T), dimension(1) :: dims_h5type(1)
  integer :: buf_(1) !< data buffer
  logical :: exists_
  integer(HID_T) :: dset_id
 
  dims_h5type(1) = 0
  !FHJ: We can`t use H5LTmake_dataset_* if the dataset already exists!
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (exists_) then
     call h5dopen_f(loc_id, dset_name, dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, (/buf/), dims_h5type, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dclose_f(dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  else
     buf_(1) = buf
     call h5ltmake_dataset_int_f(loc_id, dset_name, 0, dims_h5type, buf_, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  endif
 
end subroutine hdf5_write_int
!/* The following routine reads or writes an array, of type THE_TYPE, from the HDF5 file */
!> Writes a(n) integer array.
subroutine hdf5_write_int_array(loc_id, dset_name, dims, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in), dimension(:) :: dims !< size of the buffer buf
  integer, intent(in), dimension(*) :: buf !< data buffer
  integer, intent(out) :: errcode !< error code
  integer :: rank
  integer(HSIZE_T), dimension(size(dims)) :: dims_h5type
  logical :: exists_
  integer(HID_T) :: dset_id
 
  rank = size(dims)
  dims_h5type = dims
  !FHJ: We can`t use H5LTmake_dataset_* if the dataset already exists!
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (exists_) then
     call h5dopen_f(loc_id, dset_name, dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, buf, dims_h5type, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dclose_f(dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  else
     call h5ltmake_dataset_int_f(loc_id, dset_name, rank, dims_h5type, buf, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  endif
 
end subroutine hdf5_write_int_array
!/* The following routine reads or writes a hyperslab from an array, of type THE_TYPE, from the HDF5 file */
!> Writes a portion of a(n) integer array.
subroutine hdf5_write_int_hyperslab(loc_id, dset_name, countf, offsetf, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  !> Number of elements to read from the dataset for each dimention
  integer, intent(in) :: countf(:)
  !> Offset when reading dataset from file.
  integer, intent(in) :: offsetf(:)
  !> Data buffer. We treat it as a flat contiguous 1D array.
  integer, intent(in), dimension(*) :: buf
  integer, intent(out) :: errcode !< error code
  integer(HSIZE_T) :: hcountf(size(countf)) !< Count for file dataspace
  integer(HSIZE_T) :: hcountm(1) !< Count for memory dataspace
  integer(HSIZE_T) :: hoffsetf(size(offsetf)) !< Offset for file dataspace
  integer(HID_T) :: dset_id
  integer(HID_T) :: dataspace
  integer(HID_T) :: memspace
  logical :: exists_
 
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 1 error", only_root_writes=.true.)
  endif
  if (.not. exists_) call die('Cannot read/write hyperslap from "'//dset_name//&
       "': dataset doesn`t exists!", only_root_writes=.true.)
  call h5dopen_f(loc_id, dset_name, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 2 error", only_root_writes=.true.)
  endif
  ! FHJ: Get 2D file dataspace and set selection mask
  call h5dget_space_f(dset_id, dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 3 error", only_root_writes=.true.)
  endif
  hcountf(:) = countf(:)
  hoffsetf(:) = offsetf(:)
  call h5sselect_hyperslab_f(dataspace, H5S_SELECT_SET_F, hoffsetf, hcountf, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 4 error", only_root_writes=.true.)
  endif
  ! FHJ: Create flat memory dataspace
  hcountm(1) = product(countf)
  call h5screate_simple_f(1, hcountm, memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 5 error", only_root_writes=.true.)
  endif
  ! FHJ: Read dataspace
  call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, buf, hcountm, errcode, memspace, dataspace)
  if (errcode .ne. 0) then
     call die("HDF5 9 error", only_root_writes=.true.)
  endif
  call h5sclose_f(memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 10 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 11 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 12 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_write_int_hyperslab
!
!==============================================================================
! Included from file hdf5_io_hdf5.f90. Originally by JIM.
! Last modified 12/2014 (FHJ)
!==============================================================================
!/* The following routine reads or writes a scalar value, of type THE_TYPE, from the HDF5 file */
!> Reads a rank-0 real(DP) scalar.
subroutine hdf5_read_double(loc_id, dset_name, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  real(DP), intent(inout) :: buf !< data buffer
  integer, intent(out) :: errcode !< 1 error code
  integer(HSIZE_T), dimension(1) :: dims_h5type(1)
  real(DP), dimension(1) :: buf_1(1)
 
  dims_h5type(1) = 0
  call h5ltread_dataset_double_f(loc_id, dset_name, buf_1, dims_h5type, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  buf = buf_1(1)
 
end subroutine hdf5_read_double
!/* The following routine reads or writes an array, of type THE_TYPE, from the HDF5 file */
!> Reads a(n) real(DP) array.
subroutine hdf5_read_double_array(loc_id, dset_name, dims, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in), dimension(:) :: dims !< size of the buffer buf
  real(DP), intent(inout), dimension(*) :: buf !< data buffer
  integer, intent(out) :: errcode !< error code
  integer :: rank
  integer(HSIZE_T), dimension(size(dims)) :: dims_h5type
 
  rank = size(dims)
  dims_h5type = dims
  call h5ltread_dataset_double_f(loc_id, dset_name, buf, dims_h5type, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_read_double_array
!/* The following routine reads or writes a hyperslab from an array, of type THE_TYPE, from the HDF5 file */
!> Reads a portion of a(n) real(DP) array.
subroutine hdf5_read_double_hyperslab(loc_id, dset_name, countf, offsetf, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  !> Number of elements to read from the dataset for each dimention
  integer, intent(in) :: countf(:)
  !> Offset when reading dataset from file.
  integer, intent(in) :: offsetf(:)
  !> Data buffer. We treat it as a flat contiguous 1D array.
  real(DP), intent(inout), dimension(*) :: buf
  integer, intent(out) :: errcode !< error code
  integer(HSIZE_T) :: hcountf(size(countf)) !< Count for file dataspace
  integer(HSIZE_T) :: hcountm(1) !< Count for memory dataspace
  integer(HSIZE_T) :: hoffsetf(size(offsetf)) !< Offset for file dataspace
  integer(HID_T) :: dset_id
  integer(HID_T) :: dataspace
  integer(HID_T) :: memspace
  logical :: exists_
 
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 1 error", only_root_writes=.true.)
  endif
  if (.not. exists_) call die('Cannot read/write hyperslap from "'//dset_name//&
       "': dataset doesn`t exists!", only_root_writes=.true.)
  call h5dopen_f(loc_id, dset_name, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 2 error", only_root_writes=.true.)
  endif
  ! FHJ: Get 2D file dataspace and set selection mask
  call h5dget_space_f(dset_id, dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 3 error", only_root_writes=.true.)
  endif
  hcountf(:) = countf(:)
  hoffsetf(:) = offsetf(:)
  call h5sselect_hyperslab_f(dataspace, H5S_SELECT_SET_F, hoffsetf, hcountf, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 4 error", only_root_writes=.true.)
  endif
  ! FHJ: Create flat memory dataspace
  hcountm(1) = product(countf)
  call h5screate_simple_f(1, hcountm, memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 5 error", only_root_writes=.true.)
  endif
  ! FHJ: Read dataspace
  call h5dread_f(dset_id, H5T_NATIVE_DOUBLE, buf, hcountm, errcode, memspace, dataspace)
  if (errcode .ne. 0) then
     call die("HDF5 8 error", only_root_writes=.true.)
  endif
  call h5sclose_f(memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 10 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 11 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 12 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_read_double_hyperslab
!
!==============================================================================
! Included from file hdf5_io_hdf5.f90. Originally by JIM.
! Last modified 12/2014 (FHJ)
!==============================================================================
!/* The following routine reads or writes a scalar value, of type THE_TYPE, from the HDF5 file */
!> Writes a rank-0 real(DP) scalar.
subroutine hdf5_write_double(loc_id, dset_name, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  real(DP), intent(in) :: buf !< data buffer
  integer, intent(out) :: errcode !< 1 error code
  integer(HSIZE_T), dimension(1) :: dims_h5type(1)
  real(DP) :: buf_(1) !< data buffer
  logical :: exists_
  integer(HID_T) :: dset_id
 
  dims_h5type(1) = 0
  !FHJ: We can`t use H5LTmake_dataset_* if the dataset already exists!
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (exists_) then
     call h5dopen_f(loc_id, dset_name, dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, (/buf/), dims_h5type, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dclose_f(dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  else
     buf_(1) = buf
     call h5ltmake_dataset_double_f(loc_id, dset_name, 0, dims_h5type, buf_, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  endif
 
end subroutine hdf5_write_double
!/* The following routine reads or writes an array, of type THE_TYPE, from the HDF5 file */
!> Writes a(n) real(DP) array.
subroutine hdf5_write_double_array(loc_id, dset_name, dims, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in), dimension(:) :: dims !< size of the buffer buf
  real(DP), intent(in), dimension(*) :: buf !< data buffer
  integer, intent(out) :: errcode !< error code
  integer :: rank
  integer(HSIZE_T), dimension(size(dims)) :: dims_h5type
  logical :: exists_
  integer(HID_T) :: dset_id
 
  rank = size(dims)
  dims_h5type = dims
  !FHJ: We can`t use H5LTmake_dataset_* if the dataset already exists!
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (exists_) then
     call h5dopen_f(loc_id, dset_name, dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, buf, dims_h5type, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dclose_f(dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  else
     call h5ltmake_dataset_double_f(loc_id, dset_name, rank, dims_h5type, buf, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  endif
 
end subroutine hdf5_write_double_array
!/* The following routine reads or writes a hyperslab from an array, of type THE_TYPE, from the HDF5 file */
!> Writes a portion of a(n) real(DP) array.
subroutine hdf5_write_double_hyperslab(loc_id, dset_name, countf, offsetf, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  !> Number of elements to read from the dataset for each dimention
  integer, intent(in) :: countf(:)
  !> Offset when reading dataset from file.
  integer, intent(in) :: offsetf(:)
  !> Data buffer. We treat it as a flat contiguous 1D array.
  real(DP), intent(in), dimension(*) :: buf
  integer, intent(out) :: errcode !< error code
  integer(HSIZE_T) :: hcountf(size(countf)) !< Count for file dataspace
  integer(HSIZE_T) :: hcountm(1) !< Count for memory dataspace
  integer(HSIZE_T) :: hoffsetf(size(offsetf)) !< Offset for file dataspace
  integer(HID_T) :: dset_id
  integer(HID_T) :: dataspace
  integer(HID_T) :: memspace
  logical :: exists_
 
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 1 error", only_root_writes=.true.)
  endif
  if (.not. exists_) call die('Cannot read/write hyperslap from "'//dset_name//&
       "': dataset doesn`t exists!", only_root_writes=.true.)
  call h5dopen_f(loc_id, dset_name, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 2 error", only_root_writes=.true.)
  endif
  ! FHJ: Get 2D file dataspace and set selection mask
  call h5dget_space_f(dset_id, dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 3 error", only_root_writes=.true.)
  endif
  hcountf(:) = countf(:)
  hoffsetf(:) = offsetf(:)
  call h5sselect_hyperslab_f(dataspace, H5S_SELECT_SET_F, hoffsetf, hcountf, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 4 error", only_root_writes=.true.)
  endif
  ! FHJ: Create flat memory dataspace
  hcountm(1) = product(countf)
  call h5screate_simple_f(1, hcountm, memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 5 error", only_root_writes=.true.)
  endif
  ! FHJ: Read dataspace
  call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, buf, hcountm, errcode, memspace, dataspace)
  if (errcode .ne. 0) then
     call die("HDF5 9 error", only_root_writes=.true.)
  endif
  call h5sclose_f(memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 10 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 11 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 12 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_write_double_hyperslab
!
!==============================================================================
! Included from file hdf5_io_hdf5.f90. Originally by JIM.
! Last modified 12/2014 (FHJ)
!==============================================================================
!/* The following routine reads or writes a scalar value, of type THE_TYPE, from the HDF5 file */
!> Reads a rank-0 logical scalar.
subroutine hdf5_read_logical(loc_id, dset_name, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  logical, intent(inout) :: buf !< data buffer
  integer, intent(out) :: errcode !< 1 error code
  integer(HSIZE_T), dimension(1) :: dims_h5type(1)
  logical, dimension(1) :: buf_1(1)
  integer :: ibuf, ibuf_1(1), ibuf_(1)
 
  dims_h5type(1) = 0
  call h5ltread_dataset_int_f(loc_id, dset_name, ibuf_1, dims_h5type, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  select case (ibuf_1(1))
  case (0)
     buf = .false.
  case (1)
     buf = .true.
  case default
     call die("Invalid value for dset '"//dset_name//"'." , only_root_writes=.true.)
  endselect
 
end subroutine hdf5_read_logical
!/* The following routine reads or writes an array, of type THE_TYPE, from the HDF5 file */
!> Reads a(n) logical array.
subroutine hdf5_read_logical_array(loc_id, dset_name, dims, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in), dimension(:) :: dims !< size of the buffer buf
  logical, intent(inout), dimension(*) :: buf !< data buffer
  integer, intent(out) :: errcode !< error code
  integer :: rank
  integer(HSIZE_T), dimension(size(dims)) :: dims_h5type
  integer :: ibuf(product(dims))
  integer :: ii
 
  rank = size(dims)
  dims_h5type = dims
  call h5ltread_dataset_int_f(loc_id, dset_name, ibuf, dims_h5type, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (any(ibuf<0).or.any(ibuf>1)) then
     call die("Invalid value for dset '"//dset_name//"'." , only_root_writes=.true.)
  endif
  buf(1:product(dims)) = .false.
  do ii=1,product(dims)
     if (ibuf(ii)/=0) buf(ii) = .true.
  enddo
 
end subroutine hdf5_read_logical_array
!/* The following routine reads or writes a hyperslab from an array, of type THE_TYPE, from the HDF5 file */
!> Reads a portion of a(n) logical array.
subroutine hdf5_read_logical_hyperslab(loc_id, dset_name, countf, offsetf, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  !> Number of elements to read from the dataset for each dimention
  integer, intent(in) :: countf(:)
  !> Offset when reading dataset from file.
  integer, intent(in) :: offsetf(:)
  !> Data buffer. We treat it as a flat contiguous 1D array.
  logical, intent(inout), dimension(*) :: buf
  integer, intent(out) :: errcode !< error code
  integer(HSIZE_T) :: hcountf(size(countf)) !< Count for file dataspace
  integer(HSIZE_T) :: hcountm(1) !< Count for memory dataspace
  integer(HSIZE_T) :: hoffsetf(size(offsetf)) !< Offset for file dataspace
  integer(HID_T) :: dset_id
  integer(HID_T) :: dataspace
  integer(HID_T) :: memspace
  logical :: exists_
  integer :: ibuf(product(countf))
  integer :: ii
 
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 1 error", only_root_writes=.true.)
  endif
  if (.not. exists_) call die('Cannot read/write hyperslap from "'//dset_name//&
       "': dataset doesn`t exists!", only_root_writes=.true.)
  call h5dopen_f(loc_id, dset_name, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 2 error", only_root_writes=.true.)
  endif
  ! FHJ: Get 2D file dataspace and set selection mask
  call h5dget_space_f(dset_id, dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 3 error", only_root_writes=.true.)
  endif
  hcountf(:) = countf(:)
  hoffsetf(:) = offsetf(:)
  call h5sselect_hyperslab_f(dataspace, H5S_SELECT_SET_F, hoffsetf, hcountf, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 4 error", only_root_writes=.true.)
  endif
  ! FHJ: Create flat memory dataspace
  hcountm(1) = product(countf)
  call h5screate_simple_f(1, hcountm, memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 5 error", only_root_writes=.true.)
  endif
  ! FHJ: Read dataspace
  call h5dread_f(dset_id, H5T_NATIVE_INTEGER, ibuf, hcountm, errcode, memspace, dataspace)
  if (errcode .ne. 0) then
     call die("HDF5 6 error", only_root_writes=.true.)
  endif
  buf(1:product(countf)) = .false.
  do ii=1,product(countf)
     if (ibuf(ii)/=0) buf(ii) = .true.
  enddo
  call h5sclose_f(memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 10 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 11 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 12 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_read_logical_hyperslab
!
!==============================================================================
! Included from file hdf5_io_hdf5.f90. Originally by JIM.
! Last modified 12/2014 (FHJ)
!==============================================================================
!/* The following routine reads or writes a scalar value, of type THE_TYPE, from the HDF5 file */
!> Writes a rank-0 logical scalar.
subroutine hdf5_write_logical(loc_id, dset_name, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  logical, intent(in) :: buf !< data buffer
  integer, intent(out) :: errcode !< 1 error code
  integer(HSIZE_T), dimension(1) :: dims_h5type(1)
  logical :: buf_(1) !< data buffer
  logical :: exists_
  integer(HID_T) :: dset_id
  integer :: ibuf, ibuf_1(1), ibuf_(1)
 
  dims_h5type(1) = 0
  !FHJ: We can`t use H5LTmake_dataset_* if the dataset already exists!
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (exists_) then
     call h5dopen_f(loc_id, dset_name, dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     ibuf = 0
     if (buf) ibuf = 1
     call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, (/ibuf/), dims_h5type, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dclose_f(dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  else
     ibuf = 0
     if (buf) ibuf = 1
     ibuf_(1) = ibuf
     call h5ltmake_dataset_int_f(loc_id, dset_name, 0, dims_h5type, ibuf_, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  endif
 
end subroutine hdf5_write_logical
!/* The following routine reads or writes an array, of type THE_TYPE, from the HDF5 file */
!> Writes a(n) logical array.
subroutine hdf5_write_logical_array(loc_id, dset_name, dims, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  integer, intent(in), dimension(:) :: dims !< size of the buffer buf
  logical, intent(in), dimension(*) :: buf !< data buffer
  integer, intent(out) :: errcode !< error code
  integer :: rank
  integer(HSIZE_T), dimension(size(dims)) :: dims_h5type
  logical :: exists_
  integer(HID_T) :: dset_id
  integer :: ibuf(product(dims))
 
  rank = size(dims)
  dims_h5type = dims
  !FHJ: We can`t use H5LTmake_dataset_* if the dataset already exists!
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 error", only_root_writes=.true.)
  endif
  if (exists_) then
     call h5dopen_f(loc_id, dset_name, dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     ibuf(:) = 0
     where(buf(1:product(dims)))
        ibuf = 1
     endwhere
     call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, ibuf, dims_h5type, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
     call h5dclose_f(dset_id, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  else
     ibuf(:) = 0
     where(buf(1:dims(1)))
        ibuf = 1
     endwhere
     call h5ltmake_dataset_int_f(loc_id, dset_name, rank, dims_h5type, ibuf, errcode)
     if (errcode .ne. 0) then
        call die("HDF5 error", only_root_writes=.true.)
     endif
  endif
 
end subroutine hdf5_write_logical_array
!/* The following routine reads or writes a hyperslab from an array, of type THE_TYPE, from the HDF5 file */
!> Writes a portion of a(n) logical array.
subroutine hdf5_write_logical_hyperslab(loc_id, dset_name, countf, offsetf, buf, errcode)
  integer(HID_T), intent(in) :: loc_id !< 1 file id
  character(LEN=*), intent(in) :: dset_name !< 1 dataset name
  !> Number of elements to read from the dataset for each dimention
  integer, intent(in) :: countf(:)
  !> Offset when reading dataset from file.
  integer, intent(in) :: offsetf(:)
  !> Data buffer. We treat it as a flat contiguous 1D array.
  logical, intent(in), dimension(*) :: buf
  integer, intent(out) :: errcode !< error code
  integer(HSIZE_T) :: hcountf(size(countf)) !< Count for file dataspace
  integer(HSIZE_T) :: hcountm(1) !< Count for memory dataspace
  integer(HSIZE_T) :: hoffsetf(size(offsetf)) !< Offset for file dataspace
  integer(HID_T) :: dset_id
  integer(HID_T) :: dataspace
  integer(HID_T) :: memspace
  logical :: exists_
  integer :: ibuf(product(countf))
  integer :: ii
 
  call h5lexists_f(loc_id, dset_name, exists_, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 1 error", only_root_writes=.true.)
  endif
  if (.not. exists_) call die('Cannot read/write hyperslap from "'//dset_name//&
       "': dataset doesn`t exists!", only_root_writes=.true.)
  call h5dopen_f(loc_id, dset_name, dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 2 error", only_root_writes=.true.)
  endif
  ! FHJ: Get 2D file dataspace and set selection mask
  call h5dget_space_f(dset_id, dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 3 error", only_root_writes=.true.)
  endif
  hcountf(:) = countf(:)
  hoffsetf(:) = offsetf(:)
  call h5sselect_hyperslab_f(dataspace, H5S_SELECT_SET_F, hoffsetf, hcountf, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 4 error", only_root_writes=.true.)
  endif
  ! FHJ: Create flat memory dataspace
  hcountm(1) = product(countf)
  call h5screate_simple_f(1, hcountm, memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 5 error", only_root_writes=.true.)
  endif
  ! FHJ: Read dataspace
  ibuf(:) = 0
  do ii=1,product(countf)
     if (buf(ii)) ibuf(ii) = 1
  enddo
  call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, ibuf, hcountm, errcode, memspace, dataspace)
  if (errcode .ne. 0) then
     call die("HDF5 7 error", only_root_writes=.true.)
  endif
  call h5sclose_f(memspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 10 error", only_root_writes=.true.)
  endif
  call h5sclose_f(dataspace, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 11 error", only_root_writes=.true.)
  endif
  call h5dclose_f(dset_id, errcode)
  if (errcode .ne. 0) then
     call die("HDF5 12 error", only_root_writes=.true.)
  endif
 
end subroutine hdf5_write_logical_hyperslab
end module hdf5_io_m
!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
