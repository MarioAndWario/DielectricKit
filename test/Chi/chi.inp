chi_cutoff 5.0
number_val_bands 4
number_cond_bands 4

#skip_nvb 0
#skip_ncb 0

# #no_symmetries_coarse_grid
# use_symmetries_coarse_grid

# #no_symmetries_shifted_coarse_grid
# use_symmetries_shifted_coarse_grid

# RECOMMENDED fast FFTW truncation schemes
# The Coulomb Interaction is cutoff on the edges of
# the Wigner-Seitz Cell in the non-periodic directions
# Periodic directions are a1,a2 for slabs and a3 for wires
#cell_box_truncation
#cell_wire_truncation
#cell_slab_truncation

# Frequency dependence of the inverse dielectric matrix.
# Set to 0 to compute the static inverse dielectric matrix (default).
# Set to 2 to compute the full frequency dependent inverse dielectric matrix.
frequency_dependence 0

# Full frequency dependence method for the polarizability, if frequency_dependence==2:
# 0: Real-Axis formalism, Adler-Wiser formula.
# 1: Real-Axis formalism, spectral method (PRB 74, 035101, (2006))
# 2: Contour-Deformation formalism, Adler-Wiser formula.
#frequency_dependence_method 2

# Parameters for full-frequency-dependent calculations, in eV.
# Contour-Deformation formalism with Adler-Wiser formula (default).
# Default values, which are good for typical semiconductors. The main
# convergence knobs are:
# - broadening: should the energy resolution due to k-point sampling, or
#   a number as small as possible if you have a molecule.
# - delta_frequency: should be converged (the smaller, the better). For
#   molecules, delta_frequency should be the same as broadening.
# - low_frequency_cutoff: you should increase this valid if you wish to use
#   the Sigma code and look into QP states deep in occupied manifold or high in
#   the unoccupied manifold.

# broadening 0.2
# delta_frequency 0.2
# frequency_cutoff 94.0
# number_imaginary_freqs 15
# ## delta_freq_imag is the first non-zero imaginary frequency
# delta_freq_imag 3.0D0

# Description of the flags
# ------------------------
#
# - Each val->cond transition is broadened by "broadening".
# - A uniform frequency grid is set up from "init_frequency" (defaults to 0),
#   up to "low_frequency_cutoff", with a spacing of "delta_frequency" between
#   two frequencies.
# For methods 1 and 2:
# - A non-uniform frequency grid is setup from "low_frequency_cutoff" to
#   "high_frequency_cutoff", where the frequency spacing gets increased by
#   "delta_frequency_step".
#
# For method 2:
# - A separate frequency grid is set-up for the spectral function. The variables
#   "init_sfrequency", "delta_sfrequency", "delta_sfrequency_step",
#   "sfrequency_low_cutoff", and "sfrequency_high_cutoff" define this grid, in
#   an analogy to the flags used to define the grid for the polarizability matrix.
#
# For method 3:
# - A frequency grid with "number_imaginary_freqs" is set-up on the imag axis.

# qx qy qz 1/scale_factor is_q0
# scale_factor is for specifying values such as 1/3
# is_q0 = 0 for regular, non-zero q-vectors (read val WFNs from WFN)
# is_q0 = 1 for a small q-vector in semiconductors (read val WFNs from WFNq)
# is_q0 = 2 for a small q-vector in metals (read val WFNs from WFN)
#BEGIN_INTERNAL_ONLY
# is_q0 = -1 for non-zero q-vectors used in non-uniform sampling (read val WFNs from WFNq)
#END_INTERNAL_ONLY
# if present the small q-vector should be first in the list
# You can generate this list with kgrid.x: just set the shifts to zero and use
# same grid numbers as for WFN. Then replace the zero vector with q0.
begin qpoints
0.000000000      0.000000000     0.001000000     0
0.000000000 	 0.000000000 	 0.000000000 	 1
0.000000000 	 0.000000000 	 0.500000000 	 1
0.000000000 	 0.500000000 	 0.500000000 	 1
end

# Set this to use eigenvalues in eqp.dat and eqp_q.dat
# If not set, these files will be ignored.
#eqp_corrections

# Write the bare Coulomb potential V(q+G) to file
#write_vcoul

# Matrix Element Communication Method (Chi Sum Comm). Default is gcomm_matrix
# which is good if nk*nc*nv > nmtx*nfreq. If nk*nc*nv < nfreq*nmtx
# (nk*nv < nfreq since nc~nmtx), use gcomm_elements. Only "gcomm_elements"
# is supported with the spectral method.
#gcomm_matrix
#gcomm_elements

# Number of pools for distribution of valence bands
# The default is chosen to minimize memory in calculation
#number_valence_pools 1

# By default, the code computes the polarizability matrix, constructs
# the dielectric matrix, inverts it and writes the result to file epsmat.
# Use keyword skip_epsilon to compute the polarizability matrix and
# write it to file chimat. Use keyword skip_chi to read the polarizability
# matrix from file chimat, construct the dielectric matrix, invert it and
# write the result to file epsmat.
#skip_epsilon
#skip_chi

# The requested number of bands cannot break degenerate subspace
# Use the following keyword to suppress this check
# Note that you must still provide one more band in
# wavefunction file in order to assess degeneracy

# degeneracy_check_override

# Uncomment this flag if you would like to restart your Epsilon calculation
# instead of starting it from scratch. Note that we can only reuse q-points
# that were fully calculated. This flag is ignored unless you are running
# the code with HDF5.
#restart
#mtxel_2
